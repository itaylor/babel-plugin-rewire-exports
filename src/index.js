import template from '@babel/template';

export default function ({types: t}) {
  const VISITED = Symbol('visited');

  const defaultIdentifier = t.identifier('default');

  // TODO: bundle as separate package
  const buildRewireObjects = template(`
    import _rewireProxyRuntime from '${__dirname}/rewireProxyRuntime';
 //   import _rewireProxyRuntime from '@itaylor/babel-plugin-rewire-proxy/lib/rewireProxyRuntime.js';
  `);

  const buildRewireVarDecl = template(`
    const { _$rwRuntime, _$rwProx } = _rewireProxyRuntime();
  `);
  
  // Abuses var decl to allow to overwrite the a function with its own proxy without actually renaming the function
  const proxyFunctionTemplate = template(`
    var INTERNALNAME = EXTERNALNAME;
    var EXTERNALNAME = _$rwProx(INTERNALNAME, EXTERNALNAMESTR, () => EXTERNALNAME, (val) => EXTERNALNAME = val);
  `)

  const proxyTemplate = template(`
    var EXTERNALNAME = _$rwProx(DECL, EXTERNALNAMESTR, () => EXTERNALNAME , (val) => EXTERNALNAME = val);`);

  const defaultExportTemplate = template(`
    export default IDENT;
  `)
  

  // Wrap arrow function in an IIFE that preserves the function.name of the DECL of the function
  // This is needed for React Components that use the function.name to name the Component.
  const arrowFunctionProxyTemplate = template(`
    (() => { const EXTERNALNAME = DECL; return EXTERNALNAME; } )()
  `);

  function buildArrowFnProxyTemplate(externalName, decl) {
    const arrowFuncIIFE = arrowFunctionProxyTemplate({ DECL: decl, EXTERNALNAME: t.identifier(externalName) });
    return buildProxyTemplate(externalName, arrowFuncIIFE.expression);
  }

  function buildProxyTemplate(externalName, decl) {
    return proxyTemplate({
      DECL: decl,
      EXTERNALNAME: t.identifier(externalName),
     // INTERNALNAME: t.identifier(`${externalName}_rewire`),
      EXTERNALNAMESTR: t.stringLiteral(externalName),
    });
  }

  function markVisited(node) {
    node[VISITED] = true;
    return node;
  }
  function markAllVisited(nodeOrNodes) {
    if (nodeOrNodes.map) {
      return nodeOrNodes.map(markAllVisited);
    }
    return markVisited(nodeOrNodes);
  }

  return {
    name: 'rewire-proxies',
    visitor: {
      Program: {
        enter(_, state) {
          state.exports = [];
          state.hoistedFunctions = [];
        },
        exit(path, {exports, hoistedFunctions} ) {
          exports.push({ local: t.identifier('_$rwRuntime'), external: t.identifier('__RewireAPI__') });
          let defaultExport = null;
          let otherExportSpecifiers = [];
          exports.forEach((e) => {
            if (e?.external?.name === 'default') {
              defaultExport = defaultExportTemplate({ IDENT: e.local });
            } else {
              otherExportSpecifiers.push(t.exportSpecifier(e.local, e.external));
            }
          });
          const exportDecls = [];
          if (defaultExport) {
            exportDecls.push(markAllVisited(defaultExport));
          }
          if (otherExportSpecifiers.length) {
            exportDecls.push(markAllVisited(t.exportNamedDeclaration(null, otherExportSpecifiers)));
          }
          path.pushContainer('body', exportDecls);
          const varDecl = markVisited(buildRewireVarDecl());
          
          const hoisted = [];
          hoistedFunctions.forEach((h) => {
            proxyFunctionTemplate({ 
              EXTERNALNAME: t.identifier(h.origId),
              INTERNALNAME: t.identifier(h.newId),
              EXTERNALNAMESTR: t.stringLiteral(h.origId),
            }).forEach((n) => hoisted.push(markVisited(n)));
          });
          path.unshiftContainer('body', [varDecl, ...hoisted, markVisited(buildRewireObjects({}))]);
        }
      },
      VariableDeclaration(path) {
        if (path.node[VISITED]) return;
        if (path?.scope?.block?.type === 'Program') {
          // only modify top level variables 
          // don't modify "private" funcs prefixed with _ (babel adds some)
          const name = path?.node?.declarations[0]?.id?.name;
          if (name && name.startsWith('_')) return;
          // Already transformed this node, but some other plugin rewrote the vardecl and lost the VISITED prop, don't do it again.
          if (name && name.endsWith('_rewire')) return;
      
          //TODO: handle destructured assignment (kinda complex)...
          if (path?.node?.declarations[0]?.id.type === 'ObjectPattern') {
            markVisited(path.node);
            return;
          }
          if (path?.node?.declarations?.length === 1 && !path.node.declarations[0].init) {
            //bare var decl with no assignment.  Often generated by typescript for `enum` types.
            //skip for now?  TODO: maybe check to see if it's followed by an iife that assigns to it?
            markVisited(path.node);
            return;
          }
          const decls = path.node.declarations;
          path.replaceWithMultiple(decls.map((d) =>  {
            if (d?.init?.type === 'ArrowFunctionExpression') {
              return markVisited(buildArrowFnProxyTemplate(d.id.name, d.init));
            }
            return markVisited(buildProxyTemplate(d.id.name, d.init));
          }));
        }
      },
      ClassDeclaration(path) {
        if (path.node[VISITED]) return;
        if (path?.parent?.type === 'Program') {
          // convert ClassDecl to ClassExpression
          path.node.type = 'ClassExpression';
          path.replaceWith(markVisited(buildProxyTemplate(path.node.id.name, path.node)));
        }
      },
      FunctionDeclaration(path, { hoistedFunctions }) {
        if (path.node[VISITED]) return;
        if (path?.parent?.type === 'Program') {
          // only modify top level functions

          const origId = path.node.id.name;
          // don't modify "private" funcs prefixed with _ (babel adds some)
          if (origId.startsWith('_')) return;
          const newId = path.scope.generateUidIdentifier(origId);
          hoistedFunctions.push({ origId, newId: newId.name });
        }
      },      
      ImportDeclaration(path) {
        if (path.node[VISITED]) return;
        const specifiers = path.node.specifiers;
        for (const s of specifiers) {
          if (s.type === 'ImportDefaultSpecifier' || s.type === 'ImportSpecifier' || s.type === 'ImportNamespaceSpecifier' ) {
            const externalName = s.local.name;
            if (externalName.endsWith('_rewire')) {
              //don't mess with imports of rewire functions
              return;
            }
            const internalName = `${externalName}_rewire`;
            s.local.name = internalName;
            path.insertAfter(markVisited(buildProxyTemplate(externalName, t.identifier(internalName))));
          }
        }
        path.replaceWith(markVisited(t.ImportDeclaration(specifiers, path.node.source)));
      },
      // export default
      ExportDefaultDeclaration(path, {exports}) {
        if (path.node[VISITED]) return;
        
        const declaration = path.node.declaration;
        const isIdentifier = t.isIdentifier(declaration);
        const binding = isIdentifier && path.scope.getBinding(declaration.name);
        if (isIdentifier && binding) {
          // export default foo
          exports.push({ local: declaration, external: defaultIdentifier });
          // move the export to the end
          path.remove();
        } else if(t.isFunctionDeclaration(declaration) || t.isClassDeclaration(declaration)) {
          // export default class {
          // export default function {}
          if (!declaration?.id || declaration.id.name === 'default') {
            declaration.id = path.scope.generateUidIdentifier('default');
          }
          exports.push({ local: declaration.id, external: defaultIdentifier });
          path.replaceWith(declaration);
        } else {
          // export default "somevalue"
          const id = path.scope.generateUidIdentifier('default');
          path.replaceWith(t.variableDeclaration('const', [t.variableDeclarator(id, declaration)]));
          exports.push({ local: id, external: defaultIdentifier});
        }
      },
      // export {}
      ExportNamedDeclaration(path, {exports}) {
        if (path.node[VISITED]) return;
        // export { foo } from './bar.js'
        if (path.node.source) return;

        const declaration = path.node.declaration;
        if (t.isVariableDeclaration(declaration)) {
          // export const foo = bar, biff = baz;
          const newDeclarations = [];
          path.node.declaration.declarations.forEach((d) => {
            newDeclarations.push(t.variableDeclaration(path.node.declaration.kind, [d]));
            exports.push({ local: d.id, external: d.id });
          });
          path.replaceWithMultiple([
            ...newDeclarations,
          ]);
        } else if (t.isFunctionDeclaration(declaration) || t.isClassDeclaration(declaration)) {
          // export class foo {
          // export function foo() {}
          const id = path.node.declaration.id;
          path.replaceWithMultiple([
            declaration,
          ]);
          exports.push({ local: id, external: id });
        } else if (t?.isTSEnumDeclaration()) {
          return; // this will get converted into a VarDecl and processed later?
        } else {
          // export {foo}
          // move the named exports to the end of the file
          if (path?.node?.specifiers?.length) {
            path.node.specifiers.forEach(s => exports.push({
              local: s.local,
              external: s.exported
            }));
            path.remove();
          }
        }
      }
    }
  };
}
